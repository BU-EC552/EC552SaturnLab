The design of safe and secure synthetic biological functions is a major challenge in synthetic biology. In this undertaking, computer-aided-design (CAD) environments should play a central role by providing the required features to engineer systems: specification, analysis, and tuning (Bilitchenko et al. ; Pedersen ; Umesh et al. ; Czar et al. ). Thus, increasing the complexity of synthetic biological devices with the design of  synthetic genome as a long-term goal (Gibson et al. ) naturally leads to investigate the automatic conversion processes of the design specification into biological components like compilers for programming languages. In this context, high level programming language for synthetic biology is announced as a key milestone for the second wave of synthetic biology to overcome the complexity of synthetic system design (Purnick and Weiss ) by providing the ability for researchers to describe abstractly and concisely function while compiling it into a low level representation such as DNA sequences. However, the nature of the medium—a living organism—requires to revisit the methods used in compilation to account its specificity. Indeed, although living organism is theoretically viewed as system (Kaneko ; Kitano ), its design notably differs from other engineering systems. Usually, the design in system engineering is mostly based on a reductionist approach consisting of a hierarchical composition of inter-operable and modular parts. In this methodological context, the functionalities referring to a given level are defined as an assembly of devices corresponding to the level immediately below. For example, this methodological framework architectures the design of computer network. Although this framework is a standard for system design, the application in synthetic biology encounters some fundamental difficulties. The origin of these difficulties could be summarized by the fact that the design essentially consists in re-engineering a natural system resulting of a Darwinian selection that seemingly does not follow the afore mentioned principles in its ‘design’. In particular, the following characteristics must be accounted for the design and the compilation process: Structures with multiple functionalities The design a biological system aims at devising functionalities that do not exist in the Nature. However, pointed out by Jacob () as the consequence of the evolution, the biological components may support several functions leading to the absence of a one-to-one mapping between structures and functions. Thereby, a structure may encompass different functions. Thus, the design of a biological system can be roughly summarized as selecting a part of functionalities in components to form a device tiling the expected synthetic biological function (Stocker et al. ). Besides, The same functionality can be carried out by different biological structures. For instance the inhibition of the expression of the protein can be achieved either by an inhibitor or by RNA silencing mechanism. Interaction with the environment and incompleteness of the models The interactions can be envisioned in twofold: by considering the environmental conditions characterizing a particular context for process triggering and as a possible source of disturbance possibly preventing the realization of the expected result. Although the progress made in the field of molecular biology, the complete understanding of an organism remains out of our knowledge, then limiting the scope of the control action on the organism. a set of expected observations related to causal interactions To circumvent these difficulties, our proposal is to specify a biological function as “” and the compiler is then in charge of delivering the right assembly of biological components to obtain the expected observations. Informally, a program is here  described by the observations of causal relations. Hence, the programmer does not explicitly describe the process chain supporting a function but rather the expected observations of the designed function by emphasizing causal relations. The compiler then selects a set of components in a database such that their assembly complies to the program specification. Informally, the compilation process relies on a syntactical pattern matching such that the description of the selected components tile the description of the behaviour. Hence, a functional description of the behaviour is associated to each component and the union of the selected components behaviourally covers the programmed functionality. By contrast to the standard compilation process based on the definition of a morphism from syntax to objects of calculus underpinning the hierarchical assembly, the tiling is here global and orderless. Notice also, that only a piece of the functionality of a component could be used for this covering. Thus, the design gains in abstraction and in flexibility for component selection while accounting the multiple functionalities for a components and possible extensions. In literature, researches on programming languages for synthetic biology are mainly focused on a structural description (Czar et al. ; Pedersen ; Bilitchenko et al. ) of components used to specify a well-formed genome sequences. By contrast, our proposal is focused on the function description postponing the biological components selection at compile phase, motivated by the facts that the size of the structural description significantly increases when the complexity of programmed systems increases. Besides as the same function can be carry out by different structures (, DNA sequences), the compiler may select a component amongst a set of functionally equivalent components in accordance to a context. Beal et al. () has developed a compiler (BioCompiler) translating amorphous programs written in Proto into DNA sequence. The biological components are assimilated to actuators and logical gates. Although the compilation scheme is function oriented it differs to  on the following orientations: a  program describes the observation of a biological system instead of an amorphous process, and the compilation scheme does not assimilate the component functionalities to logic gate but describe them by causal relations allowing more flexibility for the description. Hence, the components are not necessary atomic (, promoter) but correspond to a collection of already tested components with different scales. In Rodrigo et al. (), the authors the design is based on the pathway analysis to find a way to produce specific biological compounds. In , the assembly is based on a tiling of the expected behaviour by the behaviour of the components. In this article, we study a domain specific language  and a compiler providing a framework for behavioural description of biological component while accounting the openness of such system. After introducing the main features of the language (Sect. ) we describe the compilation process (Sect. ) including the selection of biological components and we study the concrete applications of . 10441_2015_9265_Article_IEq4.gif 10441_2015_9265_Article_IEq5.gif This example introduces the main features of GUBS language applied to a regulatory network of the -phage governing the lysis–lytic cycle and involving Cro and Ci genes. The program is structured as follows: first the relations on attributes are defined, then the regulations are translated to causal relations, and finally the observers are added. Notice, that the inhibition corresponds here to macro relations , 

() The  language allows for the description of the behaviour of a biological system validated by a set of observations. In some extend, a  program collects the key-observation of an experiment, and ignore those unknown or out of the programming scope. In the following, we will base our examples on the  program of Fig.  corresponding to lysis/lysogeny genetic regulatory network of bacteriophage lambda (Thieffry and Thomas ). The network represents a switch based on two genes where each genes inhibits the other leading to two distinct equilibria. The elements of a  program are defined as follows: represent biological elements of the system. They are the atomic elements of the language. In Fig. , agents are biological elements such as  or 10441_2015_9265_Article_IEq6.gif 10441_2015_9265_Article_IEq7.gif distinguishes two types of agents:  and . Constant designates predefined element in a real corpus of knowledge such as a particular gene (,  in the example); and the variables represent an abstraction of the predefined objects. For example, a variable  may qualify a class of gene. By syntactical convention, a constant starts with an Upper case letter and variable with a lower case. 10441_2015_9265_Article_IEq8.gif 10441_2015_9265_Article_IEq9.gif The different observable states of agents will define their different possible behaviours. These states are associated to the capabilities of actions on the states of other agents. By default, an agent has two abstract states: present or absent, which may correspond to the active or inactive state of a gene for example. The notion of activity is related to the influence capability of an agent in the system. In Fig. , the rules consider the active and inactive agents. By convention, the specification of the presence is described with its name (, ) , and begin absent as a negation (, ). 10441_2015_9265_Article_IEq10.gif However, restricting the state of a biological agent to the presence or the absence of the agent appears too restrictive to finely describe the intended functionality. Indeed the variation of the concentration of an agent leads to the modification of its interaction with the other agents. In order to account the variation of its activity at different levels, we use the  characterizing different relevant states symbolically. In Fig. , attributes correspond to the variables in parenthesis, for example  in (). Notice that attributes are defined in the first lines of the program: . 10441_2015_9265_Article_IEq11.gif 10441_2015_9265_Article_IEq12.gif 10441_2015_9265_Article_IEq13.gif The biological meaning of the attributes is a matter of convention depending of the target device (, protein reaction, gene network). For example, the activity of gene regulation may correspond to the observation of different thresholds in the RNA concentration inducing different regulatory activities (Bernot et al. ). If we identify three regulation activities for a gene , the state of this gene will correspond to three different attributes . In order to describe the links between multiple attributes of the same agent, we define two types of relations between attributes qualifying their relative capacity: the order relation, , signifies “has less capacity than” meaning that the control capacity at a given state symbolized by an attribute is strictly included in another state symbolized by an attribute greater of the former; and the inequality, , signifies “has a different capacity than” meaning that the control activity is totally disjoint for any pair of unequal attributes. Symbolical attributes are completed by numerical one providing a quantification of the control activity. For example, they may define a concentration measure such as (0.3) or a range of values, such as [0.1, 0.4] meaning that the agent is active in this concentration range. Causal Relation and Observation Points 10441_2015_9265_Article_IEq14.gif 10441_2015_9265_Article_IEq15.gif Basically, a causal relation represents the control of an agent over another. In Fig. , causal relations between agents are defined as:  in , or  in () (). 10441_2015_9265_Article_IEq16.gif 10441_2015_9265_Article_IEq17.gif 10441_2015_9265_Article_IEq18.gif 10441_2015_9265_Article_IEq19.gif 10441_2015_9265_Article_IEq20.gif 10441_2015_9265_Article_IEq21.gif 10441_2015_9265_Article_IEq22.gif An historical definition of causality proposed by Hume (), is formulated in terms of regularity on events: “[we must define] a cause as an object, followed by another, and where all the similar objects to the first are followed by similar objects to the second”. Although this definition appropriately characterizes the notion of control, the openness of the system should account the actions of the environment that may alter the causal relation chain. For example, an activation  may be contradicted by an existing inhibition  on the same target gene . Although  is active, it is possible that  is not active because its action is preempted by the action of  having stronger strength than . Thus, following Hume definition, any planned causal relation could be interrupted unexpectedly by an external event. To circumvent this problem, we semantically define the causal relation in a counterfactual form (Lewis ) from the effect: “if the effect is observed, the causal relation is effective”. : if  occurs then  has occurred in a recent past. 10441_2015_9265_Article_IEq23.gif : si  occurs then  has occurred in a recent past and is still present in this moment. 10441_2015_9265_Article_IEq24.gif : si  occurs then, either  has occurred in a recent past or else  hasn’t occurred in a recent past and  then necessarily appeared. 10441_2015_9265_Article_IEq25.gif 10441_2015_9265_Article_IEq26.gif 10441_2015_9265_Article_IEq27.gif The definition of a causal relation will be refined to address the scheduling constraints between cause and effect to be able to more finely select the components corresponding expected behaviour. The causal relation primitives are defined as follows (Basso-Blandin and Delaplace ):In the sequel, we define the strong inhibition denoted  as an inhibition expressed by the program . 10441_2015_9265_Article_IEq28.gif 10441_2015_9265_Article_IEq29.gif 10441_2015_9265_Article_IEq30.gif We also define the strong activation denoted  as an activation expressed by the program 10441_2015_9265_Article_IEq31.gif 10441_2015_9265_Article_IEq32.gif 10441_2015_9265_Article_IEq33.gif To define the behaviours that we expect to observe in a program, we define the notion of . The observation spots describe the set of expected observations along an experimental trace resulting of a device assessment. Observation points are used to determine effects that must necessarily be fulfilled. In Fig. , observation spots are defined for (), () and () by ,  and . In order to describe interactions of the program with the environment, we introduce here the notion of . This notion allows us to clearly differentiate the interactions of the  program from those external to the system described by the program. Precisely, a context refers to a stimulus acting on the system that can be either environmental conditions and external signalisation. The application of a  context to a set of causal relations  is written  where  is an agent (, variable or constant) meaning that the causal relations belonging to  are triggered only if the  context is present. 10441_2015_9265_Article_IEq34.gif 10441_2015_9265_Article_IEq35.gif Finally, a  program is a set of attributes definition, observation spots and causal relations encapsulated into contexts. In order to describe the spatial organization of the biological system, we introduce a last element in the language, . A compartment encapsulates a set of causal relations, making them local. For example,  describe a normal dependence relation in the  compartment. The result of the compilation is an assembly of components where the behaviour of the generated biological system must comply to the behavioural properties described in the program. In this section, we informally describe the semantics of . Technically, the denotational semantics of  is based on multi-modal hybrid logic(HL) translating a  program into a formula (Adrien ). 10441_2015_9265_Article_IEq36.gif 10441_2015_9265_Article_IEq37.gif 10441_2015_9265_Article_IEq38.gif 10441_2015_9265_Article_IEq39.gif 10441_2015_9265_Article_IEq40.gif 10441_2015_9265_Article_IEq41.gif 10441_2015_9265_Article_IEq42.gif 10441_2015_9265_Article_IEq43.gif 10441_2015_9265_Article_Equ1.gif Validation of properties is primarily based on a set of experiments measuring the evolution of physical quantities related to agents that qualifies the states of agents. A  program describing a symbolic abstraction of these quantities, we assume it is possible to extract a  characterizing this evolution. This leads to establish a correspondence between physical quantities and attributes. A trace is a sequence,  where each  corresponds to an event composed by the state of the agents symbolised by its attributes at each instant. For example, the changes in the concentration of  to  of an agent  defined with three potential attributes , ,  can be described by the following trace composed of 6 instants (Eq. ) where each value is presumably obtained by a periodical measurement of a quantity related to  and symbolically translated.We now address the principle to extract from a trace an  defining a timeline–milestone events of the behavior evolution. Actually, all events in a trace are not necessarily relevant to validate the properties described by the program. For example, if we focus on the evolution of a concentration  to  to , only three events are relevant to this description: () and (), and (), irrespective of the intermediate stages of evolution that occur between the both, nor the repetition identical events. We will therefore adopt a different representation called an history from a chronological division of a trace in several . An history is an intentional division of a trace to highlight the relevant events emphasizing the desired properties of the behaviour of the biological system. Given a trace , and a chronological division an history is defined as a sequence of set of events occurring during each period. An history corresponds to a Kripke model with the topological property of linearity 10441_2015_9265_Article_Equ2.gif In the previous example, the period division leading to an history corresponding to the expected evolution from  to  for  is the following discrete time intervals ([1, 2], [3, 5], [6, 6]). The resulting history is:The validation of a synthetic biological function from a  program operates on histories. Formally,  () (, a graph reduced to a single path). The variables in each world (node) correspond to events (agent’s state). Hence, An history “explains” a  program if it satisfies the formula resulting from its interpretation. In some cases, an history represents a partial result of the functionalities of the program only and does not satisfy the formula interpreting the program. Hence, to validate the program it is required to gather different histories such that they will form a Kripke model satisfying the formula interpreting the program. Notice that Tableau method can generate these models (Cerrito and Mayer ). Kripke models corresponding to three types of possible causes. we denote  the cause and  the effect. In the first case, the model (1) merely imposes  to be in a previous world than . In the second case [model (2)],  must also appear in the world where  is displayed. Finally, in the third case [model (3)], the presence of  requires that either  appears in the previous world or  is displayed in the previous World () Figure  describes the Kripke models satisfying the different causal relations. Notice that model (1) is a sub-model (limited to white nodes) of model (3). Similarly, model (2) is a special case of model (1) by requiring the presence of the cause in the world of effect. It is worthwhile to point out that a model satisfying a persistent causal relation also satisfies a normal causal relation in turn satisfying remnant causal relation. 10441_2015_9265_Article_IEq44.gif 10441_2015_9265_Article_IEq45.gif 10441_2015_9265_Article_IEq46.gif The compiler selects and assembles components whose collective behaviour complies to the program specification. Schematically, the compilation principle is based on behaviour pattern matching. The behaviour of each component is also described by a  program such that the compilation algorithm collects different component-programs whose assembly “matches” with the behaviour of the programmed function. The generated device  then behaviourally “covers” the programmed function . Formally, by considering that the interpretation of  and  (,) are Hybrid logic formulas, the behavioural inclusion denoted by  characterizes the fact that  is a logical consequence of  (Definition ). 10441_2015_9265_Article_IEq47.gif 10441_2015_9265_Article_IEq48.gif () A program  another program , if and only if the interpretation of the latter is a logical consequence of the interpretation of the former:where  is a Kripke model and  are respectively the interpretation of P and Q. 10441_2015_9265_Article_IEq49.gif 10441_2015_9265_Article_IEq50.gif 10441_2015_9265_Article_IEq51.gif 10441_2015_9265_Article_IEq52.gif 10441_2015_9265_Article_IEq53.gif 10441_2015_9265_Article_IEq54.gif 10441_2015_9265_Article_IEq55.gif 10441_2015_9265_Article_IEq56.gif 10441_2015_9265_Article_IEq57.gif Functional synthesis rules () stands for the set of variables of the program and  is the restriction of the substitution on a set of variables .  is a set of components representing the library.  denotes the textual inclusion of  in 
,  where  or  may be an empty program The behavioural inclusion characterizes the condition of correctness for the compilation algorithm to insure that the assembly of components will at least reproduce the behaviour of the designed function. The behavioural inclusion property is defined from the semantics of the program. However, the compilation (the matching) is based on a syntactical comparison between the source and the assembly of component programs. Hence, the compilation process will be defined by a formal system called the  rules (Table ) denoted, . It formalizes the operations whereby biological components of a library are selected and assembled to generate a device behaviourally including the programmed function. All the rules of Table  preserve the behaviour inclusion (the proofs can be found in Basso-Blandin and Delaplace ()). Hence,  means that the observable assembly of components  is the functional synthesis of  that behaviourally includes it under the substitution of  replacing variables by constants (or other variables). It is also worth noticing that the satisfiability of the formula interpreting  is checked to prevent the incompatible assembly revealed here by a false formula. This property is called the observability of  ( in Table ) informally meaning that the assembly does not produce an infeasible behaviour. Rule (Inst.) describes the fact that an observable instance of a part of a component in the library is functionally synthesized. Rule (Com.) expresses the commutativity of the assembly. Rule (Cont.) contracts the redundant formulation of programs. Finally, Rule (Asm.) details the conditions for an assembly of two components, each representing a functional synthesis of a part of the designed function. Another set of rules (Adrien ) not presented here defines the alternate possibilities to express similar behaviours in order to find components if no components in the database fit to the matching. The algorithm derived from the formal system can be assimilated to a general unification algorithm (Knight ) called the  (Baader and Büttner ; Baader and Snyder ) (Associative, Commutative, Idempotent). For the unification, causal rules correspond to normalized terms to unify and a program to a conjunction of terms. ACI-Unification is an NP-Complete problem and the algorithm explores all the possibilities until an unification is found or fail (Baader and Büttner ; Baader and Snyder ). To improve the algorithm, we account the specificity of  language. The performance of the algorithms actually depends on the size of the database where the components are stored. For a small set of components, the ACI-unification algorithm selects a subset of components behaviourally covering the initial program  in the whole database. However, for large database, the unification may be too time-consuming to be effective. In this case, the unification will operate on a part of it. The issue is to appropriately select of a subset of components behaviourally covering . The selection is achieved by a  evolutionary algorithm where the individuals represent a possible subset of components. By directed we mean that we proceed to a pre-selection, checking whether each individual (subset of components) will not obviously cause the unification failure. Hence, the functional synthesis algorithm is structured in two stages: the ACI-unification algorithm and the directed evolutionary algorithm. An individual represents a subset of components. The best individuals have the minimal number of unified components and maximize the number of unified rules in the program. 10441_2015_9265_Article_IEq58.gif 10441_2015_9265_Article_IEq59.gif 10441_2015_9265_Article_IEq60.gif 10441_2015_9265_Article_IEq61.gif 10441_2015_9265_Article_IEq62.gif Based on ACI unification, the functional synthesis takes benefit of the specificity of the language to heuristically improve the selection of subset of components forming the individuals of a population. The heuristics implies to define a relation between causal relations of  and the components  of a database. The relation accounts the structure of the causal rule and the nature of the agents.  is assumed to be a set of causes . The relation qualifies a  of  where each cause of  can be associated to a cause of a subset of components  without accounting the interplays between the unification of different causal rules. If the causes  is not related to some s then the ACI-unification surely fails. Constraints on causal relation. 10441_2015_9265_Article_IEq63.gif 10441_2015_9265_Article_IEq64.gif 10441_2015_9265_Article_IEq65.gif 10441_2015_9265_Article_IEq66.gif 10441_2015_9265_Article_IEq77.gif 10441_2015_9265_Article_IEq78.gif 10441_2015_9265_Article_IEq79.gif 10441_2015_9265_Article_IEq80.gif 10441_2015_9265_Article_IEq67.gif 10441_2015_9265_Article_IEq68.gif 10441_2015_9265_Article_IEq69.gif 10441_2015_9265_Article_IEq70.gif All constants of  are present in  in there respective side of the causal relation(cause or effect). 10441_2015_9265_Article_IEq71.gif 10441_2015_9265_Article_IEq72.gif The cardinality of the both set of agents representing the cause and the effect of  is greater or equal to the cardinality of the respective set in . 10441_2015_9265_Article_IEq73.gif 10441_2015_9265_Article_IEq74.gif Each agent of  has a counterpart in , with the same order on their attributes. 10441_2015_9265_Article_IEq75.gif 10441_2015_9265_Article_IEq76.gif For each agent of , the number of attributes is lower or equal to the agent counter part in . A causal rule  is related to a component  if and only if there exists a causal rule  of  such that:Once a relation between the causal relations of  and those of the components is established, the algorithm selects a subset of components such that there exists at least one causal relation  fulfilling the previous constraints for each  of . Notice that, different components  of  can cover the same causal rule  of . Next, before performing the ACI-unification algorithm between an individual  and , we validate some necessary conditions on the agents. The number of occurs of a constant in  must be lower or equal to the number of occurs of the same constant in . For each variable  of , there exists at least one constant of  that does not belong to the constants of  whose number of occur is greater or equal to the number of occurs of  in . Besides the order on the attributes is the same and the number of attributes of the constant is greater the number of attributes of the analysed variable . The agents constraints are the following:The constraints on agents are refined by considering the side of the occur of agents on a causal relation, either as a cause or effect. The main steps of the behavioural matching algorithm are defined in Fig. . Example: Compilation of the Repressilator GUBS program of the repressilator 10441_2015_9265_Article_IEq81.gif 10441_2015_9265_Article_IEq82.gif 10441_2015_9265_Article_IEq83.gif 10441_2015_9265_Article_IEq84.gif 10441_2015_9265_Article_IEq85.gif 10441_2015_9265_Article_IEq86.gif 10441_2015_9265_Article_IEq87.gif 10441_2015_9265_Article_IEq88.gif 10441_2015_9265_Article_IEq89.gif 10441_2015_9265_Article_IEq90.gif is locally associated to all the components 10441_2015_9265_Article_IEq91.gif 10441_2015_9265_Article_IEq92.gif is locally associated to  due to the  in the effect side 10441_2015_9265_Article_IEq93.gif 10441_2015_9265_Article_IEq94.gif 10441_2015_9265_Article_IEq95.gif and finally,  is locally associated to  and . By application of the first step of the algorithm, we define the relation that locally associate each  to s. 10441_2015_9265_Article_Equ3.gif Thus, the following population of individuals is generated: 10441_2015_9265_Article_IEq96.gif 10441_2015_9265_Article_IEq97.gif Due to the second rule applied to 2, we conclude that  and  cannot cover  because  is used in  so it cannot be a substitution of 2. 10441_2015_9265_Article_IEq98.gif 10441_2015_9265_Article_IEq99.gif 10441_2015_9265_Article_IEq100.gif 10441_2015_9265_Article_IEq101.gif As for 2, , , ,  cannot cover  because  is used in  so it cannot be substituted to 1. 10441_2015_9265_Article_IEq102.gif The unification of  fails because no constants other than  appear more than once. 10441_2015_9265_Article_IEq103.gif Similarly the unification of  fails  because no constants other than  appear once in a cause and once in an effect. By application of the agent constraints we have: 10441_2015_9265_Article_IEq104.gif 10441_2015_9265_Article_IEq105.gif Hence,  and  constitute the remaining choices. 10441_2015_9265_Article_IEq106.gif With this step, using , 2 can be substituted to  but 1 cannot be unified. 10441_2015_9265_Article_IEq107.gif So the remaining solution is  where 2 is substituted with  and 1 with . The next step of the algorithm consists in the substitution of each variable to constant: 10441_2015_9265_Article_IEq108.gif The final solution  corresponds to the biological description of the Repressilator. In this section, we sketch the application of the algorithm to the Repressilator (Elowitz and Leibler ) example (Fig. ). The Repressilator circuit is one of the first synthetic system leading to oscillation of fluorescent protein (GFP) monitored by a circuit of three genes, each one inhibiting another. To simplify the presentation we apply the algorithm on a piece of the database used for the effective compilation (Fig. ). In the sequel,the causal relations are labelled by  as follows: g1!g2, g2!TetR_lite, TetR_lite!g1.Here, due to the unification properties, only one solution is possible, but, in most of the case, several solutions are available. In this case, the potential solutions are ordered with respect to fitness properties. Benchmarks and Numerical Results The first curve represent the compilation time evolution (in s) for a 10 causal relations sized program and the second for a 25 causal relations sized program In order to empirically validate the functional synthesis algorithm, we executed  on several data sets. Those data sets are based on databases containing randomly generated 100 components. In order to insure a solution for the tested program and the fact that the compiling time-out is due to the lack of time finding a solution, each program is generated by selecting a subset of components in the database. Execution time on the following curves correspond to program containing respectively 10 and 25 causal relations. In order to show the impact of the number of agents and constants on the compiling time, those numbers evolve from 1 to 10 on each program (Fig. ). Those curves confirm the theoretical hypothesis. In fact, we observe that the time evolve exponentially function of the number of variables and not of the agents because constants restrict the possibility of choices. In conclusion, the efficiency of the compilation directly depends on the number of constants corresponding to the known agents. In this article, we have described the main features of , a language for synthetic biology based on a behavioural description of the designed biological function. The compilation principle relies on the covering of the behaviour of a programmed function by the behaviour of a collection of components. The behavioural covering corresponds to a matching between component specification and the programmed function specification. The compiler combines the ACI-unification algorithm with a directed evolutionary algorithm enabling to analyse large biological database. We have demonstrated the proof-of-concept of the compilation with a prototype applied on some realistic examples. GGC is implemented in Ocaml, using XML files for the database (the platform is freely available in open source on Basso-Blandin et al. ()). GGC has been tested on multiple randomly generated examples and databases (Adrien ). In the future, we could imagine that the design in synthetic biology will require different programming layouts based on different language paradigms structured in a tower of languages and addressing different levels of integration in biology. From a language describing collective operations on cell colonies (Giavitto et al. ; Beal et al. ) the program will be translated into different intermediate representations to end by a structural low level description programmed in a grammar based language (Cai et al. ) of genome sequences. In this tower, the  language occupies the intermediary level dedicated to cell entity behavioural programming. The tower could be completed by methods ensuring the safety of the generated system by a verification of the non-toxicity and simulation for accurately assessing its performance. The integration of these methods could rely on the realization of a connection with existing tools based on a translation of a  program into formalism dedicated to toxicity checking as in Giusto et al. () and languages for simulation such as Kappa (Danos et al. ) or Biocham (Calzone et al. )..